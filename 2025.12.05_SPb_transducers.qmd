---
format: 
  beamer:
    theme: Singapore
    mainfont: Brill
    monofont: Iosevka
    df-print: kable
    pdf-engine: xelatex
    cite-method: natbib
    classoption: t
    header-includes: |
       \setbeamertemplate{footline}[page number]
       \setbeamercolor{alerted text}{fg=teal}
title: "Зачем нужен правиловый морфологический анализ в XXI веке?"
subtitle: "Язык, текст, культура через призму цифровых технологий \n\n НИУ ВШЭ, Санкт-Петербург \n\n 04--05 декабря 2025"
lang: ru
author: 
  - name: "Г. А. Мороз НИУ ВШЭ, Москва \n\n Международная лаборатория языковой конвергенции"
date: "12/05/2025"
date-format: "D.MM.YYYY"
bibliography: references.bib
execute: 
  echo: false
  warning: false
fig-align: center  
urlcolor: teal
citecolor: teal
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false

# setwd("/home/agricolamz/work/materials/2025.12.05_SPb_transducers")
```


# Зачем нужен морфологический анализ?

## Что такое морфологический анализ

Морфологический анализ, как его обычно видят лингвисты, обычно включает в себя несколько вещей:

- определение морфологической формы (например, латинское *mensam* --- [acc.sg]{.smallcaps});
- приведение к начальной форме или основе (*mensam* --- *mensa*, ж. р., первое склонение);
- перевод основы (*mensam* --- 'стол'). \pause

Не бывает правильного морфологического анализа --- это каждый раз компромисс между языковой моделью, конвенциями исследователей и текущеми задачами. Например, лингвисты, приводя примеры, редко перечисляют несловоизменительную информацию (например, род для существительных).

## Зачем нужен морфологический анализ?

- Польза от морфологически размеченных текстов для теоретической лингвистики неоценима \pause
- В области NLP --- все не так однозначно:
  - Какие-то задачи можно решить при помощи *стэминга*
  - Выгода зависит от языка к языку
  - Легко представить, что в некоторых задачах выгоднее иметь лишь какую-то часть морфологического анализа, например, частеречную разметку

# Подходы к морфологическому анализу

## Много данных

Обычно, если много данных, люди используют нейросети. Для морфологического анализа русского языка их использовали в следующих работах [@arefyev18; @sorokin18; @bolshakova19a; @bolshakova19b; @bolshakova20; @garipov23]. Используются разные архитектуры:

- cвёрточные нейронные сеть (convolutional neural network, CNN);
- деревья решения с градиентным бустингом (decision trees with gradient boosting);
- двунаправленная длинная цепь элементов краткосрочной памяти (Biderectional long short-term memory network, Bi-LSTM); \pause
- [UDPipe](https://ufal.mff.cuni.cz/udpipe/2) --- проект, основанный на размеченных в формате [Universal Dependencies трибанках](https://universaldependencies.org/) большого количества языков  [@straka18]. Внутри: LSTM, которая работает на основе векторного представления слов.
- [Morfessor](http://morpho.aalto.fi/projects/morpho/), в котором используют скрытые марковские цепи [@gronroos14].

## Мало данных

В случаях, когда ресурсов мало, используют правиловые методы

- проект `uniparser-morph` Тимофея Архангельского [@arkhangelskiy12];
- нечто, что работает в SIL Fieldworks;
- множество узконаправленных парсеров, написанных для конкертных языков;
- морфологические анализаторы на основе трансдьюсеров
  - Helsinki Finite-State Tookit `hfst` [@linden11];
  - аналогичным инструментом от сообщества Apertium `lttoolbox` [@ortiz05].

# Морфологические трансдьюсеры

## Конечные автоматы

Теория автоматов --- это дисциплина на стыке математики и компьютерных наук, которая появилась в XX веке. Первые конечных автоматов были предложены в работах [@mealy55; @moore56]. Данный раздел основан на первой главе из [@beesley03: 1--42].

Под автоматами мы понимаем абстрактные машины, которые принимают разные состояния, а изменение состояний вызывается некоторым действием.

## Конечные автоматы

```{r}
#| out-width: 100%
#| layout: "[[1,3],[1,3]]"

knitr::include_graphics("images/01_01_light_switch.jpg")
knitr::include_graphics("images/01_02_light_switch_automaton.png")
knitr::include_graphics("images/01_03_turnstile.jpg")
knitr::include_graphics("images/01_04_turnstile_automaton.png")
```

## Конечные автоматы

Конечных автоматы состоят:

- алфавит, который автомат понимает;
- конечное количество состояний;
- переходы между состояниями;
- одно начальное состояние (часто обозначют нулем);
- набор конечных состояний (часто обозначают двойным кружочком).

Конечные автоматы можно использовать для побуквенной верефикации поданных на вход слов.

## Конечные автоматы

```{r}
#| out-width: 100%

knitr::include_graphics("images/01_05_elephant.png")
```

Если программа смогла пройти путь до конечного состояния (обозначен двойным кружочком), значит операция завершилась успехом, в остальных случаях --- неудачей.

## Конечные автоматы

```{r}
#| out-width: 100%

knitr::include_graphics("images/01_06_elephant_short.png")
```

Обычно путь, ведущий к неудаче, не отображают.

## Конечные автоматы

```{r}
#| out-width: 100%

knitr::include_graphics("images/01_07_multiple_words.png")
```

Можно сделать так, чтобы автомат верефицировал несколько слов.

## Конечные автоматы

```{r}
#| out-width: 100%

knitr::include_graphics("images/01_08_multiple_words_optimized.png")
```

Полученный автомат можно оптимизировать, так, чтобы там было меньше узлов, а задачи он решал те же самые.

## Трансдьюсеры

```{r}
#| out-width: 100%

knitr::include_graphics("images/01_09_first_transducer.png")
```

Если мы немного усложним автомат, добавив в него еще выходной алфавит, то мы получим трансдьюсер (в [русской википедии](https://ru.wikipedia.org/wiki/Конечный_автомат_с_выходом) они названы конечными автоматами с выходом). Мы будем использовать обновленную нотацию: то, что представлено на вход, мы пишем слева от двоеточия, а то, что получается на выходе --- справа.

## Трансдьюсеры

```{r}
#| out-width: 100%

knitr::include_graphics("images/01_10_morphology.png")
```

Введя обозначение пустой строки, которую принято обозначать греческой буквой эпсилон `ε`,  мы можем представить трансдьюсер, который, наконец-то, делает некоторый морфологический анализ.

## Операции с трансдьюсерами

С трансдьюсерами можно делать много разных операций:

- инвертирование;
- объединение (конечные и начальные состояния совпадают, все промежуточные сохраняются);
- конкатенация (конечное состояние одного трансдьюсера становится начальным состоянием другого);
- пересечение (в особых случаях;
- вычитание (в особых случаях);
- композиция.

## Композиция трансдьюсеров

```{r}
#| out-width: 100%

knitr::include_graphics("images/01_11_transducer_composition.png")
```

\pause

Вообще перевод близкородственных языков при помощи трансдьюсеров делают, но алгоритм там конечно умнее:

- запускаем анализатор языка A;
- составляем правила соответствий переходов от лемм и морфологических форм языка А в язык B;
- дальше запускаем генератор языка B;
- запускаем правила постобработки.

Так как трансдьюсеры обратимы --- данная последовательность действий будет работать в обе стороны.

## Морфология `lexd`

\small

```
PATTERNS
Noun NounInflection
Noun Suffix AdjInflection

LEXICON Noun
ночь
печь

LEXICON Suffix
<adj>:н

LEXICON NounInflection
<nom><sg>:
<ins><pl>:ами

LEXICON AdjInflection
<m><nom><sg>:ой
<f><nom><sg>:ая
```

## Морфология `lexd`

\small

```
ночь<nom><sg>:ночь
печь<nom><sg>:печь
ночь<ins><pl>:ночьами
печь<ins><pl>:печьами
ночь<adj><m><nom><sg>:ночьной
печь<adj><m><nom><sg>:печьной
ночь<adj><f><nom><sg>:ночьная
печь<adj><f><nom><sg>:печьная
```

## Двухуровневая фонология/морфология

Двухуровневая фонология/морфология (two level morphology) была разработана в диссертации [@koskenniemi1983]. Еще в 1972 вышла диссертация [@johnson1972], в которой автор указывал на некоторые недостатки последовательности фонологических правил, которые были приняты в генеративной фонологии, а также доказывал, что любую последовательность правил можно моделировать при помощи трансдьюсера.

## Двухуровневая фонология/морфология

В рамках двухуровневой фонологии/морфологии:

- правила --- посимвольные ограничения на поверхностное представление, которые применяются параллельно.
- правила могут оперировать единицами глубинного представления, поверхностного представления или одновременно обоих.

Например, получить из глубинной формы `spy>s` поверхностную форму `spies`  можно двумя правилами:

- `y:i < = > _ 0:e`
- `0:e < = > y: _ %>:0`

## (Мор)фонология `twol`

\small

```
Alphabet
  а е я й к н о п ч ь ь:0;

Rules

"чк чн пишется без ь"
! например, ночьной -> ночной или печька -> печка

ь:0 < = > _ н;
          _ к;
```

## (Мор)фонология `twol`

\small

```
ночь<nom><sg>:ночь
печь<nom><sg>:печь
ночь<ins><pl>:ночьами
печь<ins><pl>:печьами
ночь<adj><m><nom><sg>:ночной
печь<adj><m><nom><sg>:печной
ночь<adj><f><nom><sg>:ночная
печь<adj><f><nom><sg>:печная
```

## Разрешение морфологической неоднозначности `cg3`

Парадигма Constraint grammar (CG) [@karlsson1995; @bick15] --- это правиловая процедурная система обработки текста, позволяющая решать достаточно большой набор разнообразных задач, такие как

- разрешение неоднозначности;
- приписывание тэгов, например, синтаксических ролей;
- разрешение анафоры;
- построение деревьев зависимостей;
- chunking --- выделение границ синтаксических единиц (без внутренней структуры, отношений вершины-зависимое и т. п.) [@bick2013];
- и многие другие.

## Что необходимо для создания морфологического анализатора?

- грамматическое описание;
- словарь;
- корпус текстов
  - без морфологической разметки;
  - с морфологической разметкой.

## Проблемы моделирования морфологии языка

- Проблема описаний:
    - неполнота: то, что исследователи посчитали достаточным для грамматического описания, может быть недостаточно для моделирования; для некоторого языка может быть доступно грамматическое описание, но отсутствовать словарь и наоборот; словарь может не содержать информации про словоизменительный класс каких-то единиц, которые различаются в грамматическом описании.
    - противоречивые источники: грамматические описания могут противоречить друг другу; грамматические описания могут противоречить словарям
- Проблема вариативности:
    - идиолектная
    - диалектная
    - связанная с какими-нибудь социолингвистическими параметрами (в первую очередь такие как пол и возраст, но можно придумать и другие)
    
## Проблемы моделирования морфологии языка

- Проблема неоднозначности (особенно перекошенной частотно):
    - лексической
    - морфологическая
    - синтаксическая
    - ...
- Проблема идиом (выйти за *муж*) и суплетивизма
- Проблема циклов, возникающих при словообразовании:
    - слуга (N) > служить (V) > услужить (V) > услужение (N), услуга (N)
- Проблема морфологической сложности: для языков с бедной морфологией проще строить прсотой правиловый морфологический парсер, а не трансдьюсер

## Что читать?

- [Онлайн материалы](https://agricolamz.github.io/2025_morphological_transducers/) нашего с Т. Казаковой курса в НИУ ВШЭ
- [документацию](https://github.com/apertium/lexd/blob/main/Usage.md) `lexd`
- введение в `twol` в [@beesley2003]
- [документацию](https://edu.visl.dk/cg3/chunked/index.html) `cg3`
- [ACL Antology](https://aclanthology.org/):
  - [morphological transducers](https://aclanthology.org/search/?q=morphological+transducers) --- около 3440 результатов
  - [transducers](https://aclanthology.org/search/?q=morphological+transducers) --- около 6450 результатов 

## {}

\vfill
\centering \LARGE
\alert{Спасибо за внимание!}
\vfill

# Ссылки на литературу